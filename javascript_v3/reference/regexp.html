<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>RegExp - JavaScript 高级程序设计 V3 | 柚子胖鸡_</title><meta name="baidu-site-verification" content="code-QQXB3LWw5E" />
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1d4b09c687aa7d9e66a6041d5b5f58f1";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="keywords" content="JaimeCheng, 静态博客, Github Page, Jekyll">
  <meta name="description" content="JaimeCheng's Blog，记录前端笔记、生活杂事、读书随笔等。"><link rel="stylesheet" href="/assets/main.css?v=0.2.5" />
<link rel="stylesheet" href="/assets/my.css" />
<script src="/assets/main.js?v=0.2.5" defer></script><link rel="stylesheet" href="/assets/css/tomorrow.css" />
<script src="/assets/js/highlight.js"></script></head>
<body class="body-chapter">
    <div class="book__wrapper sidebar-right" id="bookMain"><div class="book-summary" id="bookSummary">
  <nav role="navigation">
    <ul class="summary">
      <li class="chapter ">
        <a href="/javascript_v3/" class="custom-link">JavaScript 高级程序设计 V3</a>
      </li>
      <li class="divider"></li><li class="chapter "><a href="/javascript_v3/README.html">JavaScript 高级程序设计</a></li><li class="chapter "><a href="/javascript_v3/content/README.html">章节内容</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/content/chapter01.html">1. JavaScript 简介</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter02.html">2. 在 HTML 中使用 JavaScript</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter03.html">3. JavaScript 基本概念</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter04.html">4. 变量、作用域和内存问题</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter05.html">5. 引用类型</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter06.html">6. 面向对象的程序设计</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter07.html">7. 函数表达式</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter08.html">8. BOM</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter09.html">9. 客户端检测</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter10.html">10. DOM</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter11.html">11. DOM 扩展</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter12.html">12. DOM2 和 DOM3</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter13.html">13. 事件</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter14.html">14. 表单脚本</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter15.html">15. 使用 Canvas 绘图</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter16.html">16. HTML5 脚本编程</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter17.html">17. 错误处理与调试</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter18.html">18.  JavaScript 与 XML</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter19.html">19. E4X</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter20.html">20. JSON</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter21.html">21. Ajax 与 Comet</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter22.html">22. 高级技巧</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter23.html">23. 离线应用与客户端存储</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter24.html">24. 最佳实践</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter25.html">25. 新兴的 API</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/datatype/README.html">数据类型</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/datatype/undefined.html">Undefined</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/null.html">Null</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/boolean.html">Boolean</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/number.html">Number</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/string.html">String</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/object.html">Object</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/reference/README.html">引用类型</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/reference/array.html">Array</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/object.html">Object</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/function.html">Function</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/date.html">Date</a>
          </li><li class="chapter active">
            <a href="/javascript_v3/reference/regexp.html">RegExp</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/primitive-wrapper.html">基本包装类型</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/singleton-built-in-object.html">单体内置对象</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/quiz/README.html">专项练习</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/quiz/operator.html">操作符</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/statement.html">语句</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/array.html">数组</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/function.html">函数</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/appendix/README.html">附录</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/appendix/operator-rules.html">操作符特殊规则</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/appendix/use-strict.html">严格模式规则</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/appendix/compatibility.html">兼容性汇总</a>
          </li></ul></li></ul>
  </nav>
</div>
<div class="book__body">
    <div class="body__inner"><a href="/" class="logo"><img src="/img/logo.png" class="logo_img"><h1>柚子胖鸡_</h1>
</a>
<!--<a href="/archive/" class="sidebar__toggler">
  <span class="sidebar__toggler_top"></span>
  <span class="sidebar__toggler_middle"></span>
  <span class="sidebar__toggler_bottom"></span>
</a> --><div class="book-header" role="navigation">
    <a href="#" id="summaryToggler" class="summary__toggler">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="1"></circle>
  <circle cx="19" cy="12" r="1"></circle>
  <circle cx="5" cy="12" r="1"></circle>
</svg>

    </a>
  <h1>
    RegExp - JavaScript 高级程序设计 V3
  </h1>
</div><main class="chapter__wrapper" tabindex="-1" role="main">
        <div class="chapter__inner">
          <article class="chapter__content content">
            <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#regexp">RegExp</a>
<ul>
<li class="toc-entry toc-h2"><a href="#实例属性-">实例属性 </a></li>
<li class="toc-entry toc-h2"><a href="#实例方法-">实例方法 </a></li>
<li class="toc-entry toc-h2"><a href="#构造函数属性-">构造函数属性 </a></li>
<li class="toc-entry toc-h2"><a href="#模式的局限性-">模式的局限性 </a></li>
</ul>
</li>
</ul><h1 id="regexp">
<a class="anchor" href="#regexp" aria-hidden="true"><span class="octicon octicon-link"></span></a>RegExp</h1>

<p>ECMAScript 通过 <code class="language-plaintext highlighter-rouge">RegExp</code> 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正则表达式。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">expression</span> <span class="o">=</span> <span class="sr">/ pattern /</span> <span class="nx">flags</span> <span class="p">;</span>
</code></pre></div></div>
<p>其中的模式 (pattern) 部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。每个正则表达式都可带有一或多个标志 (flags)，用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
  <li>
<strong>g</strong>：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即 停止；</li>
  <li>
<strong>i</strong>：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
  <li>
<strong>m</strong>：表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。</li>
</ul>

<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括: <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">[</code> <code class="language-plaintext highlighter-rouge">{</code> <code class="language-plaintext highlighter-rouge">\</code> <code class="language-plaintext highlighter-rouge">^</code> <code class="language-plaintext highlighter-rouge">$</code> <code class="language-plaintext highlighter-rouge">|</code> <code class="language-plaintext highlighter-rouge">)</code> <code class="language-plaintext highlighter-rouge">?</code> <code class="language-plaintext highlighter-rouge">*</code> <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">.</code> <code class="language-plaintext highlighter-rouge">]</code> <code class="language-plaintext highlighter-rouge">}</code> ，这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 字面量形式来定义的正则表达式</span>
<span class="kd">var</span> <span class="nx">pattern0</span> <span class="o">=</span> <span class="sr">/at/g</span><span class="p">;</span> <span class="c1">// 匹配字符串中所有"at"的实例</span>
<span class="kd">var</span> <span class="nx">pattern1</span> <span class="o">=</span> <span class="sr">/</span><span class="se">[</span><span class="sr">bc</span><span class="se">]</span><span class="sr">at/i</span><span class="p">;</span> <span class="c1">// 匹配第一个"bat"或"cat"，不区分大小写</span>
<span class="kd">var</span> <span class="nx">pattern2</span> <span class="o">=</span> <span class="sr">/</span><span class="se">\[</span><span class="sr">bc</span><span class="se">\]</span><span class="sr">at/i</span><span class="p">;</span> <span class="c1">// 匹配第一个" [bc]at"，不区分大小写</span>
<span class="kd">var</span> <span class="nx">pattern3</span> <span class="o">=</span> <span class="sr">/.at/gi</span><span class="p">;</span> <span class="c1">// 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span>
<span class="kd">var</span> <span class="nx">pattern4</span> <span class="o">=</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">at/gi</span><span class="p">;</span> <span class="c1">// 匹配所有".at"，不区分大小写</span>
</code></pre></div></div>
<p>另一种创建正则表达式的方式是使用 <code class="language-plaintext highlighter-rouge">RegExp</code> 构造函数，它接收两个参数:一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">pattern1</span> <span class="o">=</span> <span class="sr">/</span><span class="se">[</span><span class="sr">bc</span><span class="se">]</span><span class="sr">at/i</span><span class="p">;</span> <span class="c1">// 匹配第一个"bat"或"cat"，不区分大小写</span>
<span class="kd">var</span> <span class="nx">pattern2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="dl">"</span><span class="s2">[bc]at</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">i</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 与 pattern1 相同，只不过是使用构造函数创建的</span>
</code></pre></div></div>
<p>要注意的是，传递给 <code class="language-plaintext highlighter-rouge">RegExp</code> 构造 函数的两个参数都是字符串(不能把正则表达式字面量传递给 <code class="language-plaintext highlighter-rouge">RegExp</code> 构造函数)。由于 <code class="language-plaintext highlighter-rouge">RegExp</code> 构造 函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如<code class="language-plaintext highlighter-rouge">\n</code>(字符<code class="language-plaintext highlighter-rouge">\</code>在字符串中通常被转义为<code class="language-plaintext highlighter-rouge">\\</code>，而在正则表达式字符串中就变成<code class="language-plaintext highlighter-rouge">\\\\</code>)。</p>

<h2 id="实例属性-">
<a class="anchor" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-" aria-hidden="true"><span class="octicon octicon-link"></span></a>实例属性 <a id="instance-properties"></a>
</h2>

<p><code class="language-plaintext highlighter-rouge">RegExp</code> 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息，但却没有多大用处，因为这些信息全都包含在模式声明中。</p>

<ul>
  <li>
<strong>global</strong>：布尔值，表示是否设置了 g 标志；</li>
  <li>
<strong>gnoreCase</strong>：布尔值，表示是否设置了 i 标志；</li>
  <li>
<strong>lastIndex</strong>：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起；</li>
  <li>
<strong>multiline</strong>：布尔值，表示是否设置了 m 标志；</li>
  <li>
<strong>source</strong>：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。保存的是规范形式的字符串，即字面量形式所用的字符串。
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">pattern2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="dl">"</span><span class="se">\\</span><span class="s2">[bc</span><span class="se">\\</span><span class="s2">]at</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">i</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nb">global</span><span class="p">);</span> <span class="c1">//false</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">ignoreCase</span><span class="p">);</span> <span class="c1">//true</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">multiline</span><span class="p">);</span> <span class="c1">//false</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">);</span> <span class="c1">//0</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">source</span><span class="p">);</span> <span class="c1">//"\[bc\]at"</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="实例方法-">
<a class="anchor" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-" aria-hidden="true"><span class="octicon octicon-link"></span></a>实例方法 <a id="instance-methods"></a>
</h2>

<ul>
  <li>
<strong>exec()</strong>：专门为捕获组而设计的。接受一个参数，即 要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 <code class="language-plaintext highlighter-rouge">null</code>。返回的数组虽然是 <code class="language-plaintext highlighter-rouge">Array</code> 的实例，但包含两个额外的属性：<code class="language-plaintext highlighter-rouge">index</code> 和 <code class="language-plaintext highlighter-rouge">input</code>。
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">mom and dad and baby</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="sr">/mom</span><span class="se">(</span><span class="sr"> and dad</span><span class="se">(</span><span class="sr"> and baby</span><span class="se">)?)?</span><span class="sr">/gi</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
<span class="c1">// ["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span> <span class="c1">// 0, 匹配项在字符串中的位置</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span> <span class="c1">// "mom and dad and baby", 应用正则表达式的字符串</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 数组第一项与整个模式匹配的字符串</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 数组其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div>    </div>
    <p>对于 <code class="language-plaintext highlighter-rouge">exec()</code> 方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 <code class="language-plaintext highlighter-rouge">exec()</code> 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 <code class="language-plaintext highlighter-rouge">exec()</code> 则都会在字符串中继续查找新匹配项。</p>
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">cat, bat, sat, fat</span><span class="dl">"</span><span class="p">;</span> 
<span class="kd">var</span> <span class="nx">pattern1</span> <span class="o">=</span> <span class="sr">/.at/</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="nx">pattern1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span> 
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span> <span class="c1">//0 </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">//cat </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern1</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">);</span> <span class="c1">//0</span>
<span class="nx">matches</span> <span class="o">=</span> <span class="nx">pattern1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span> 
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span> <span class="c1">//0 </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">//cat </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern1</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">);</span> <span class="c1">//0</span>
<span class="kd">var</span> <span class="nx">pattern2</span> <span class="o">=</span> <span class="sr">/.at/g</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="nx">pattern2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span> 
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span> <span class="c1">//0 </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">//cat </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">);</span> <span class="c1">//3</span>
<span class="nx">matches</span> <span class="o">=</span> <span class="nx">pattern2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span> 
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span> <span class="c1">//5 </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">//bat </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern2</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">);</span> <span class="c1">//8</span>
</code></pre></div>    </div>
    <p><em>IE 的 JavaScript 实现在 <code class="language-plaintext highlighter-rouge">lastIndex</code> 属性上存在偏差，即使在非全局模式下，<code class="language-plaintext highlighter-rouge">lastIndex</code> 属性每次也会变化。</em></p>
  </li>
  <li>
<strong>test()</strong>：接受一个字符串参数。在模式与该参数匹配的情况下返回 <code class="language-plaintext highlighter-rouge">true</code>；否则返回 <code class="language-plaintext highlighter-rouge">false</code>。
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">000-00-0000</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="sr">/</span><span class="se">\d{3}</span><span class="sr">-</span><span class="se">\d{2}</span><span class="sr">-</span><span class="se">\d{4}</span><span class="sr">/</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">text</span><span class="p">)){</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">The pattern was matched.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">RegExp</code> 实例继承的 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。正则表达式的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回正则表达式本身。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="dl">"</span><span class="se">\\</span><span class="s2">[bc</span><span class="se">\\</span><span class="s2">]at</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">gi</span><span class="dl">"</span><span class="p">);</span> 
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// /\[bc\]at/gi </span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">());</span> <span class="c1">// /\[bc\]at/gi</span>
<span class="nx">pattern</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">()</span>    <span class="c1">// /\[bc\]at/gi</span>
</code></pre></div></div>

<h2 id="构造函数属性-">
<a class="anchor" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7-" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数属性 <a id="constructor-properties"></a>
</h2>

<p><code class="language-plaintext highlighter-rouge">RegExp</code> 构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名 (Opera 是例外，它不支持短属性名)。下表列出了 RegExp 构造函数的属性：
<img src="../imgs/5-5.png" alt=""></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">this has been a short summer</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(</span><span class="sr">.</span><span class="se">)</span><span class="sr">hort/g</span><span class="p">;</span>
<span class="c1">// 注意:Opera 不支持 input、lastMatch、lastParen 和 multiline 属性 * Internet Explorer 不支持 multiline 属性</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span>  <span class="c1">// this has been a short summer</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">leftContext</span><span class="p">);</span> <span class="c1">// this has been a 短属性名方括号访问 alert(RegExp["$`"]);</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">rightContext</span><span class="p">);</span> <span class="c1">// summer</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">lastMatch</span><span class="p">);</span> <span class="c1">// short</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">lastParen</span><span class="p">);</span>  <span class="c1">// s</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nb">RegExp</span><span class="p">.</span><span class="nx">multiline</span><span class="p">);</span> <span class="c1">// false</span>
<span class="p">}</span>
</code></pre></div></div>
<p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语 法是 <code class="language-plaintext highlighter-rouge">RegExp.$1</code>、<code class="language-plaintext highlighter-rouge">RegExp.$2</code>…<code class="language-plaintext highlighter-rouge">RegExp.$9</code>，分别用于存储第一、第二……第九个匹配的捕获组。在 调用 <code class="language-plaintext highlighter-rouge">exec()</code> 或 <code class="language-plaintext highlighter-rouge">test()</code> 方法时，这些属性会被自动填充。</p>

<h2 id="模式的局限性-">
<a class="anchor" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7-" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式的局限性 <a id="pattern-limitations"></a>
</h2>

<p>尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言(特别是 Perl)所支 持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性。</p>
<ul>
  <li>匹配字符串开始和结尾的\A 和\Z 锚「但支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾」；</li>
  <li>向后查找(lookbehind)「但完全支持向前查找(lookahead)」；</li>
  <li>并集和交集类；</li>
  <li>原子组(atomic grouping)；</li>
  <li>Unicode 支持(单个字符除外，如<code class="language-plaintext highlighter-rouge">\uFFFF</code>)；</li>
  <li>命名的捕获组「但支持编号的捕获组」；</li>
  <li>s(single，单行)和 x(free-spacing，无间隔)匹配模式；</li>
  <li>条件匹配；</li>
  <li>正则表达式注释；</li>
</ul>

          </article>
        </div><footer class="site-footer">
  © 2020<a href="/">柚子胖鸡_</a>. Theme<a href="https://github.com/erlzhang/jekyll-theme-persephone" target="_blank">Persephone</a>
</footer>
</main>
    </div><a href="/javascript_v3/reference/date.html" class="navigation navigation-prev" aria-label="Previous page: Date"><svg viewBox="0 0 32 32" width="32" height="32" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
  <path d="M20 30 L8 16 20 2" />
</svg>
</a><a href="/javascript_v3/reference/primitive-wrapper.html" class="navigation navigation-next" aria-label="Next page: 基本包装类型"><svg viewBox="0 0 32 32" width="32" height="32" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
  <path d="M12 30 L24 16 12 2" />
</svg>
</a></div>
</div><script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
