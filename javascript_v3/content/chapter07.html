<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>7. 函数表达式 - JavaScript 高级程序设计 V3 | 柚子胖鸡_</title><meta name="baidu-site-verification" content="code-QQXB3LWw5E" />
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1d4b09c687aa7d9e66a6041d5b5f58f1";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="keywords" content="JaimeCheng, 柚子胖鸡_, 静态博客, Github Page, Jekyll">
  <meta name="description" content="JaimeCheng's Blog，不太高产的前端日常。"><link rel="stylesheet" href="/assets/main.css?v=0.2.5" />
<link rel="stylesheet" href="/assets/my.css" />
<script src="/assets/main.js?v=0.2.5" defer></script>
<script src="/assets/my.js" defer></script><link rel="stylesheet" href="/assets/css/tomorrow.css" />
<script src="/assets/js/highlight.js"></script></head>
<body class="body-chapter">
    <div class="book__wrapper sidebar-right" id="bookMain"><div class="book-summary" id="bookSummary">
  <nav role="navigation">
    <ul class="summary">
      <li class="chapter ">
        <a href="/javascript_v3/" class="custom-link">JavaScript 高级程序设计 V3</a>
      </li>
      <li class="divider"></li><li class="chapter "><a href="/javascript_v3/README.html">JavaScript 高级程序设计</a></li><li class="chapter "><a href="/javascript_v3/content/README.html">章节内容</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/content/chapter01.html">1. JavaScript 简介</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter02.html">2. 在 HTML 中使用 JavaScript</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter03.html">3. JavaScript 基本概念</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter04.html">4. 变量、作用域和内存问题</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter05.html">5. 引用类型</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter06.html">6. 面向对象的程序设计</a>
          </li><li class="chapter active">
            <a href="/javascript_v3/content/chapter07.html">7. 函数表达式</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter08.html">8. BOM</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter09.html">9. 客户端检测</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter10.html">10. DOM</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter11.html">11. DOM 扩展</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter12.html">12. DOM2 和 DOM3</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter13.html">13. 事件</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter14.html">14. 表单脚本</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter15.html">15. 使用 Canvas 绘图</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter16.html">16. HTML5 脚本编程</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter17.html">17. 错误处理与调试</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter18.html">18.  JavaScript 与 XML</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter19.html">19. E4X</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter20.html">20. JSON</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter21.html">21. Ajax 与 Comet</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter22.html">22. 高级技巧</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter23.html">23. 离线应用与客户端存储</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter24.html">24. 最佳实践</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/content/chapter25.html">25. 新兴的 API</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/datatype/README.html">数据类型</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/datatype/undefined.html">Undefined</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/null.html">Null</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/boolean.html">Boolean</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/number.html">Number</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/string.html">String</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/datatype/object.html">Object</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/reference/README.html">引用类型</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/reference/array.html">Array</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/object.html">Object</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/function.html">Function</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/date.html">Date</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/regexp.html">RegExp</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/primitive-wrapper.html">基本包装类型</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/reference/singleton-built-in-object.html">单体内置对象</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/quiz/README.html">专项练习</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/quiz/operator.html">操作符</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/statement.html">语句</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/array.html">数组</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/quiz/function.html">函数</a>
          </li></ul></li><li class="chapter "><a href="/javascript_v3/appendix/README.html">附录</a><ul class="articles"><li class="chapter ">
            <a href="/javascript_v3/appendix/operator-rules.html">操作符特殊规则</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/appendix/use-strict.html">严格模式规则</a>
          </li><li class="chapter ">
            <a href="/javascript_v3/appendix/compatibility.html">兼容性汇总</a>
          </li></ul></li></ul>
  </nav>
</div>
<div class="book__body">
    <div class="body__inner"><a href="/" class="logo"><img src="/img/logo.png" class="logo_img"><h1>柚子胖鸡_</h1>
</a>
<!--<a href="/archive/" class="sidebar__toggler">
  <span class="sidebar__toggler_top"></span>
  <span class="sidebar__toggler_middle"></span>
  <span class="sidebar__toggler_bottom"></span>
</a> --><div class="book-header" role="navigation">
    <a href="#" id="summaryToggler" class="summary__toggler">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="1"></circle>
  <circle cx="19" cy="12" r="1"></circle>
  <circle cx="5" cy="12" r="1"></circle>
</svg>

    </a>
  <h1>
    7. 函数表达式 - JavaScript 高级程序设计 V3
  </h1>
</div><main class="chapter__wrapper" tabindex="-1" role="main">
        <div class="chapter__inner">
          <article class="chapter__content content">
            <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#7-函数表达式">7. 函数表达式</a>
<ul>
<li class="toc-entry toc-h2"><a href="#函数表达式--">函数表达式  </a></li>
<li class="toc-entry toc-h2"><a href="#递归--">递归  </a></li>
<li class="toc-entry toc-h2"><a href="#闭包-">闭包 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#闭包与变量--">闭包与变量  </a></li>
<li class="toc-entry toc-h4"><a href="#关于-this-对象--">关于 this 对象  </a></li>
<li class="toc-entry toc-h4"><a href="#内存泄漏--">内存泄漏  </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#模仿块级作用域-">模仿块级作用域 </a></li>
<li class="toc-entry toc-h2"><a href="#私有变量-">私有变量 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#静态私有变量-">静态私有变量 </a></li>
<li class="toc-entry toc-h4"><a href="#模块模式-">模块模式 </a></li>
<li class="toc-entry toc-h4"><a href="#增强的模块模式-">增强的模块模式 </a></li>
</ul>
</li>
</ul>
</li>
</ul><h1 id="7-函数表达式">
<a class="anchor" href="#7-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. 函数表达式</h1>

<h2 id="函数表达式--">
<a class="anchor" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F--" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数表达式  <a id="expression"></a>
</h2>

<ul>
  <li>
    <p>函数表达式与其他表达式一样，使用前必须先赋值；所以不像函数声明那样有函数提升；</p>

    <div class="language-javascript highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fnAdd</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fnAdd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>上述示例中，赋值给变量的没有名字的函数叫做<a href="../reference/function.md#anonymous">匿名函数</a>，有时也叫拉姆达函数；</p>
  </li>
</ul>

<h2 id="递归--">
<a class="anchor" href="#%E9%80%92%E5%BD%92--" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归  <a id="recursion"></a>
</h2>

<ul>
  <li>
    <p>递归函数是在一个函数通过名字调用自身的情况下构成的，即函数自己调用自己；</p>
  </li>
  <li>
    <p>递归应用场景：无限极分类、文件夹遍历、树形列表等，经典案例：汉诺塔问题；</p>
  </li>
  <li>
    <p>递归必须有退出递归的条件否则成为死循环；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// 经典阶乘函数</span>
<span class="kd">function</span> <span class="nx">factorial</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="kd">var</span> <span class="nx">another</span> <span class="o">=</span> <span class="nx">factorial</span><span class="p">;</span>
<span class="nx">factorial</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">another</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 出错 factorial is not a function</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>以上代码先把 <code class="language-plaintext highlighter-rouge">factorial()</code> 函数保存在变量 <code class="language-plaintext highlighter-rouge">another</code> 中，然后将 <code class="language-plaintext highlighter-rouge">factorial</code> 变量设置为 <code class="language-plaintext highlighter-rouge">null</code>，结果指向原始函数的引用只剩下一个。但在接下来调用<code class="language-plaintext highlighter-rouge">another()</code> 时，由于必须执行 <code class="language-plaintext highlighter-rouge">factorial()</code>，而 <code class="language-plaintext highlighter-rouge">factorial</code> 已经不再是函数，所以就会导致错误。在这种情况下，使用 <code class="language-plaintext highlighter-rouge">arguments.callee</code> 可以解决这个问题；</p>
  </li>
  <li>
    <p>递归函数应始终使用 <code class="language-plaintext highlighter-rouge">arguments.callee</code> 来递归地调用自身，不是用函数名，因其可能发生变化；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">factorial</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">arguments.callee</code>  是指向正在执行的函数的指针，但严格模式下不可用；</p>
  </li>
  <li>
    <p>严格模式或非严格模式下递归调用并降低耦合的方式如下：</p>
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">factroial</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="nx">f</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">f</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">})</span> <span class="c1">// 外部不能调用f()</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="闭包-">
<a class="anchor" href="#%E9%97%AD%E5%8C%85-" aria-hidden="true"><span class="octicon octicon-link"></span></a>闭包 <a id="closures"></a>
</h2>

<p><strong>闭包</strong> 是指 可以访问读取其他函数（包含函数）作用域中的变量的函数，创建闭包的常见方式：在一个函数内部创建（声明）另一个函数；</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createCompariFunction</span> <span class="p">(</span><span class="nx">propertyName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj1</span><span class="p">,</span> <span class="nx">obj2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value1</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">[</span><span class="nx">propertyName</span><span class="p">];</span> <span class="c1">// 访问了外部函数中的变量propertyName</span>
    <span class="kd">var</span> <span class="nx">value2</span> <span class="o">=</span> <span class="nx">obj2</span><span class="p">[</span><span class="nx">propertyName</span><span class="p">];</span> <span class="c1">// 同上</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value1</span> <span class="o">&lt;</span> <span class="nx">value2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">value1</span> <span class="o">&gt;</span> <span class="nx">value2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">turn</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//创建函数</span>
<span class="kd">var</span> <span class="nx">compareNames</span> <span class="o">=</span> <span class="nx">createComparisonFunction</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">//调用函数</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">compareNames</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Nicholas</span><span class="dl">"</span> <span class="p">},</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Greg</span><span class="dl">"</span> <span class="p">});</span>
<span class="c1">//解除对匿名函数的引用（以便释放内存）通知垃圾回收例程将其清除</span>
<span class="nx">compareNames</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="c1">// 对比</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">B</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">A</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nx">B</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">A</span><span class="p">();</span>  <span class="c1">// 输出3，闭包是一个函数在另一个函数内声明而不是调用，这里是一个回调函数</span>
</code></pre></div></div>

<p>要理解闭包必须深刻理解执行环境和作用域链，详见<a href="chapter04.md#execution-context-scope">第4章</a>；</p>

<p>在这个例子中，打注释的两行代码访问了外部函数中的变量propertyName，之所以能访问，是因为内部函数的作用域链包含 <code class="language-plaintext highlighter-rouge">createCompariFunction()</code>  的作用域；</p>

<p>在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在 <code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 <code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 的活动对象。下图展示了当上述列代码执行时，包含函数与内部匿名函数的作用域链。</p>

<p><img src="../imgs/7-1.png" alt=""></p>

<p>在匿名函数从 <code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 中被返回后，它的作用域链被初始化为包含 
<code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 函数的活动对象和全局变量对象。这样，匿名函数就可以访问在
<code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 中定义的所有变量。更为重要的是，<code class="language-plaintext highlighter-rouge">createComparisonFunction()</code>函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 <code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后， <code class="language-plaintext highlighter-rouge">createComparisonFunction()</code> 的活动对象才会被销毁；</p>

<p>由于闭包会携带外部函数的作用域，因此比其他函数占更多的内存。建议只在绝对必要时再考虑使用闭包；</p>

<h4 id="闭包与变量--">
<a class="anchor" href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E5%8F%98%E9%87%8F--" aria-hidden="true"><span class="octicon octicon-link"></span></a>闭包与变量  <a id="closures&amp;variables"></a>
</h4>

<ul>
  <li>
    <p>作用域链的这种配置机制有一个值得注意的副作用，<strong>闭包只能取得包含函数中任何变量的最后一个值</strong>；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createFunctions</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// for立即执行的，而闭包函数尚未调用，调用的时候i已经=3了</span>
<span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">createFunctions</span><span class="p">()</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]());</span>		<span class="c1">// 3</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]());</span>		<span class="c1">// 3</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]());</span>		<span class="c1">// 3</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="mi">3</span><span class="p">]());</span>		<span class="c1">// res[3] is not a function</span>
</code></pre></div>    </div>

    <p>表面上看，似乎每个函数都应该返自己的索引值，当 <code class="language-plaintext highlighter-rouge">createFunctions()</code> 函数返回后，变量 i 的值是 3，此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是 3。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示：</p>
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createFunctions</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num</span><span class="p">){</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="k">return</span> <span class="nx">num</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 也可以将原例中的var 换成 let ，与这个版本一样效果</span>
</code></pre></div>    </div>
    <p>在这个版本中，没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋
给数组。 这里的匿名函数有一个参数 <code class="language-plaintext highlighter-rouge">num</code>，也就是最终的函数要返回的值。在调用每个匿名函数时，传入了变量<code class="language-plaintext highlighter-rouge"> i</code>。由于函数参数是按值传递的，所以就会将变量 <code class="language-plaintext highlighter-rouge">i</code> 的当前值复制给参数 <code class="language-plaintext highlighter-rouge">num</code>。而在这个匿名函数内部，又创建并返回了一个访问 <code class="language-plaintext highlighter-rouge">num</code> 的闭包。这样一来，<code class="language-plaintext highlighter-rouge"> result</code> 数组中的每个函数都有自己 <code class="language-plaintext highlighter-rouge">num</code> 变量的一个副本，因此就可以返回各自不同的数值了；</p>
  </li>
  <li>
    <p>经典闭包案例，要深刻理解掌握：</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">var定义i: </span><span class="dl">'</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span> 
  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">let定义i: </span><span class="dl">'</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span> 
  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 在for循环内部 var 定义的变量也可以在外部访问到</span>
<span class="c1">// let声明只在代码块中有效</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="关于-this-对象--">
<a class="anchor" href="#%E5%85%B3%E4%BA%8E-this-%E5%AF%B9%E8%B1%A1--" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于 this 对象  <a id="this-object"></a>
</h4>

<ul>
  <li>
    <p>在全局函数中， <code class="language-plaintext highlighter-rouge">this</code> 等于 <code class="language-plaintext highlighter-rouge">window</code>，而当函数被作为某个对象的方法调用时， <code class="language-plaintext highlighter-rouge">this</code> 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 <code class="language-plaintext highlighter-rouge">this</code> 对象通常指向 <code class="language-plaintext highlighter-rouge">window</code>，当然，在通过 <code class="language-plaintext highlighter-rouge">call()</code> 或 <code class="language-plaintext highlighter-rouge">apply()</code> 改变函数执行环境的情况下，<code class="language-plaintext highlighter-rouge">this</code> 就会指向其他对象 。 在闭包中使用 <code class="language-plaintext highlighter-rouge">this</code> 对象可能会导致一些问题；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">The Window</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">My Object</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">getNameFunc</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getNameFunc</span><span class="p">()());</span> <span class="c1">//"The Window"（在非严格模式下）</span>
</code></pre></div>    </div>

    <p>为什么匿名函数没有取得其包含作用域（或外部作用域）的 <code class="language-plaintext highlighter-rouge">this</code> 对象呢？
前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量： <code class="language-plaintext highlighter-rouge">this</code> 和 <code class="language-plaintext highlighter-rouge">rguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量，不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，如下所示 ：</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">The Window</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">My Object</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">getNameFunc</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getNameFunc</span><span class="p">()());</span> <span class="c1">//"My Object"</span>
</code></pre></div>    </div>

    <p>把 <code class="language-plaintext highlighter-rouge">this</code> 对象赋值给了一个名叫 <code class="language-plaintext highlighter-rouge">that</code> 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是在包含函数中特意声明的一个变量。即使在函数返回之后， <code class="language-plaintext highlighter-rouge">that</code> 也仍然引用着 <code class="language-plaintext highlighter-rouge">object</code>，所以调用就返回了”My Object”；</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">arguments </code>也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中 ;</p>
  </li>
  <li>
    <p>在几种特殊情况下， <code class="language-plaintext highlighter-rouge">this</code> 的值可能会意外地改变。比如，下面的代码是修改前面例子的结果 ：</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">The Window</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">My Object</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
  
<span class="nx">object</span><span class="p">.</span><span class="nx">getName</span><span class="p">();</span> <span class="c1">//"My Object"</span>
<span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getName</span><span class="p">)();</span> <span class="c1">//"My Object"</span>
<span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">object</span><span class="p">.</span><span class="nx">getName</span><span class="p">)();</span> <span class="c1">//"The Window"，在非严格模式下</span>
</code></pre></div>    </div>

    <p>第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但 <code class="language-plaintext highlighter-rouge">this</code> 的值得到了维持，因为 <code class="language-plaintext highlighter-rouge">object.getName</code> 和 <code class="language-plaintext highlighter-rouge">(object.getName)</code> 的定义是相同的 ；</p>

    <p>第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 <code class="language-plaintext highlighter-rouge">this</code> 的值不能得到维持，结果就返回了”The Window”；</p>
  </li>
</ul>

<h4 id="内存泄漏--">
<a class="anchor" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存泄漏  <a id="memory-leaks"></a>
</h4>

<p>由于 IE9 之前的版本对 JScript 对象和 COM 对象使用不同的垃圾收集例程，因此闭包在 IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。来看下面的例子 ：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">assignHandler</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">someElement</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="nx">alert</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上代码创建了一个作为 <code class="language-plaintext highlighter-rouge">element</code> 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用（<a href="chapter04.md#garbage-collection">第4章 - 垃圾收集</a>已经学习过）；由于匿名函数保存了一个对 <code class="language-plaintext highlighter-rouge">assignHandler()</code> 的活动对象的引用，因此就会导致无法减少 <code class="language-plaintext highlighter-rouge">element</code> 的引用数。只要匿名函数存在， <code class="language-plaintext highlighter-rouge">element</code> 的引用数至少也是 1，因此它所占用的内存就永远不会被回收 。不过，这个问题可以通过稍微改写一下代码来消除循环引用，如下所示 ：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">assignHandler</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">someElement</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="nx">alert</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">element</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过把 <code class="language-plaintext highlighter-rouge">element.id</code> 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但还是不能解决内存泄漏的问题。必须要记住：<strong>闭包会引用包含函数的整个活动对象</strong>，而其中包含着 <code class="language-plaintext highlighter-rouge">element</code>。即使闭包不直接引用 <code class="language-plaintext highlighter-rouge">element</code>，包含函数的活动对象中也仍然会保存一个引用。因此，把 <code class="language-plaintext highlighter-rouge">element</code> 变量设置为 <strong><code class="language-plaintext highlighter-rouge">null</code></strong>。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存 ；</p>

<h2 id="模仿块级作用域-">
<a class="anchor" href="#%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-" aria-hidden="true"><span class="octicon octicon-link"></span></a>模仿块级作用域 <a id="mimicking-block-scope"></a>
</h2>
<ul>
  <li>
    <p>JavaScript没有块级作用域的概念，匿名函数可以用来模仿块级作用域，用作块级作用域（通常称为<strong>私有作用域</strong>）的匿名函数的语法如下所示：</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 这里是块级作用域</span>
<span class="p">})();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">F</span> <span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">})();</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 报错：i is not defined</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>这个例子中，我们在 <code class="language-plaintext highlighter-rouge">for</code> 循环外部插入了一个私有作用域，在匿名函数中定义的任何变量，都会在执行结束时被销毁；</p>
  </li>
  <li>
    <p>这种用法经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数；一般来说，应当尽量少向全局作用域中添加变量和函数，通过创建私有作用域，协作开发的每个开发人员能使用自己的变量而不会污染全局作用域；</p>
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span><span class="p">.</span><span class="nx">getDate</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
  	<span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Happy new year!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})();</span>
</code></pre></div>    </div>

    <p>上述代码放在全局作用域中使用，其中给的 <code class="language-plaintext highlighter-rouge">now</code> 是匿名函数中的局部变量，不必在全局创建；这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就立即销毁其作用域了；</p>
  </li>
</ul>

<h2 id="私有变量-">
<a class="anchor" href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F-" aria-hidden="true"><span class="octicon octicon-link"></span></a>私有变量 <a id="private-variables"></a>
</h2>

<ul>
  <li>
    <p>任何在函数内部定义的变量，都可以认为是私有变量；利用闭包能通过自己的作用域链可以访问这些变量的特点，就可以创建用于访问私有变量的公有方法。故把有权访问私有变量和私有函数的公有方法成为<strong>特权方法</strong>；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">};</span> <span class="c1">// 特权方法</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">};</span> <span class="c1">// 特权方法</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Nicholas</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Jaime</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Nicholas"  // 特权方法可以在构造函数外部使用，  有权访问私有变量name</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person2</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Jaime"  // 每个实例都会创建一次该方法</span>
<span class="nx">person1</span><span class="p">.</span><span class="nx">setName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Greg</span><span class="dl">"</span><span class="p">);</span>                       
<span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Greg"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数；但在<code class="language-plaintext highlighter-rouge">Person</code> 构造函数外部，没有任何办法访问私有变量 <code class="language-plaintext highlighter-rouge">name</code> ；</p>
  </li>
  <li>
    <p>这种在构造函数中定义特权方法的缺点：必须使用构造函数达到目的，而构造函数的缺点是针对每个实例都会创建同样的一组新方法；使用 <strong>静态私有变量</strong> 实现特权方法可以避免这一问题；</p>
  </li>
</ul>

<h4 id="静态私有变量-">
<a class="anchor" href="#%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F-" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态私有变量 <a id="static-private-variables"></a>
</h4>

<ul>
  <li>
    <p>通过在私有作用域中定义私有变量或函数，也能创建特权方法；</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">''</span>
  <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">=</span> <span class="nx">val</span>
  <span class="p">}</span> <span class="c1">// 没有用函数声明，函数声明只能创建局部函数</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">name</span>
  <span class="p">}</span>
<span class="p">})()</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">jaime</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">cheng</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="nx">getName</span><span class="p">())</span> <span class="c1">// cheng</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">getName</span><span class="p">())</span> <span class="c1">// cheng</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在私有作用域中，定义了私有变量和私有函数，然后又定义了构造函数及其公有方法，公有方法是在其原型上定义的，这点体现了典型的原型模式；</p>
  </li>
  <li>
    <p>这种模式与在构造函数中定义特权方法区别，在于私有变量和函数是由实例共享，因为特权方法是在原型上定义，因此所有实例都是用同一个函数；上例中，变量 <code class="language-plaintext highlighter-rouge">name</code> 就变成了一个静态的、由所有实例共享的属性；</p>
  </li>
  <li>
    <p>这种方式创建静态私有变量会因为使用原型而增加代码复用，但每个实例没有自己的私有变量，具体怎么使用两种方式视你的需求而定；该模式主要用于为自定义类型创建私有变量和特权方法；</p>
  </li>
  <li>
    <p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度，而这正是使用闭包和私有变量的明显不足；</p>
  </li>
</ul>

<h4 id="模块模式-">
<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F-" aria-hidden="true"><span class="octicon octicon-link"></span></a>模块模式 <a id="module-pattern"></a>
</h4>

<p>前面的模式是用于为自定义类型创建的私有变量和特权方法，而模块模式是为单例创建私有变量和特权方法；所谓单例，指的就是只有一个实例的对象；照惯例，js是以对象字面量来创建单例对象的；</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="c1">//私有变量和函数</span>
  <span class="kd">var</span> <span class="nx">components</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
  <span class="c1">//初始化</span>
  <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">BaseComponent</span><span class="p">());</span> <span class="c1">// 这里不需要关心BaseComponent的代码</span>
  <span class="c1">//公共</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">getComponentCount</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">components</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="na">registerComponent</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">component</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span><span class="p">){</span>
        <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}();</span>
</code></pre></div></div>

<ul>
  <li>
<strong>模块模式</strong>使用了一个返回对象字面量的匿名函数；从本质讲，这个对象字面量定义的是单例的公共接口；这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的；</li>
  <li>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用<strong>模块模式</strong>；以这种模式创建的每个单例都是 <code class="language-plaintext highlighter-rouge">Object</code> 的实例，因为最终都要以一个对象字面量来表示它；</li>
</ul>

<h4 id="增强的模块模式-">
<a class="anchor" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F-" aria-hidden="true"><span class="octicon octicon-link"></span></a>增强的模块模式 <a id="module-augmentation-pattern"></a>
</h4>

<p>在返回对象之前加入对其增强的代码，这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况；</p>

<p>如果上述模块模式的例子中 <code class="language-plaintext highlighter-rouge">application</code> 对象必须是 <code class="language-plaintext highlighter-rouge">BaseComponent</code> 的实例，那么就可以如下改造：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="c1">//私有变量和函数</span>
  <span class="kd">var</span> <span class="nx">components</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
  <span class="c1">//初始化</span>
  <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">BaseComponent</span><span class="p">());</span>
  <span class="c1">//创建 application 的一个局部副本</span>
  <span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BaseComponent</span><span class="p">();</span>
  <span class="c1">//公共接口</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">getComponentCount</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">components</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">registerComponent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">component</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span><span class="p">){</span>
      <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">//返回这个副本</span>
  <span class="k">return</span> <span class="nx">app</span><span class="p">;</span>
<span class="p">}();</span>
</code></pre></div></div>

<p>重写之后的不同之处在于命名变量 <code class="language-plaintext highlighter-rouge">app</code> 的创建过程，因为他必须是 <code class="language-plaintext highlighter-rouge">BaseComponent</code> 的实例；这个实例实际上是 <code class="language-plaintext highlighter-rouge">application</code> 对象的局部变量；</p>

          </article>
        </div><footer class="site-footer">
  © 2020<a href="/">柚子胖鸡_</a>. Theme<a href="https://github.com/erlzhang/jekyll-theme-persephone" target="_blank">Persephone</a>
</footer>
</main>
    </div><a href="/javascript_v3/content/chapter06.html" class="navigation navigation-prev" aria-label="Previous page: 6. 面向对象的程序设计"><svg viewBox="0 0 32 32" width="32" height="32" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
  <path d="M20 30 L8 16 20 2" />
</svg>
</a><a href="/javascript_v3/content/chapter08.html" class="navigation navigation-next" aria-label="Next page: 8. BOM"><svg viewBox="0 0 32 32" width="32" height="32" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
  <path d="M12 30 L24 16 12 2" />
</svg>
</a></div>
</div><script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
